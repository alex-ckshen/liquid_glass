<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Water Droplet - Tuning Console</title>
    <style>
        body{font-family:Arial,sans-serif;background:#fff;background-image:linear-gradient(#ccc 1px,transparent 1px),linear-gradient(90deg,#ccc 1px,transparent 1px);background-size:20px 20px;margin:0;padding:0;height:100vh;width:100vw;overflow:hidden;cursor:pointer}
        #water-droplet-container{position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:1}
        #controls{position:fixed;top:10px;left:10px;background:rgba(0,0,0,.4);backdrop-filter:blur(10px);padding:15px;border-radius:10px;color:#fff;z-index:1000;font-size:12px;width:250px}
        .control-group{margin-bottom:10px}
        .control-group h3{margin:0 0 10px;font-size:14px;border-bottom:1px solid rgba(255,255,255,.2);padding-bottom:5px}
        .control-group label{display:block;margin-bottom:3px}
        .control-group input[type=range]{width:100%}
        .control-group span{float:right;font-weight:700}
    </style>
</head>
<body>
    <div id="controls">
        <div class="control-group">
            <h3>Physics</h3>
            <label>Stretch<span id="stretch-value"></span></label>
            <input type="range" id="stretch" min="0" max="0.5" step="0.01">
            <label>Squash<span id="squash-value"></span></label>
            <input type="range" id="squash" min="0" max="0.5" step="0.01">
            <label>Damping<span id="damping-value"></span></label>
            <input type="range" id="damping" min="0.8" max="0.99" step="0.001">
        </div>
        <div class="control-group">
            <h3>Appearance</h3>
            <label>Refraction<span id="refraction-value"></span></label>
            <input type="range" id="refraction" min="0" max="0.3" step="0.01">
            <label>Fresnel Power<span id="fresnel-value"></span></label>
            <input type="range" id="fresnel" min="1" max="15" step="0.1">
            <label>Rim Start<span id="rim-start-value"></span></label>
            <input type="range" id="rim-start" min="0.1" max="1.0" step="0.01">
            <label>Rim Strength<span id="rim-strength-value"></span></label>
            <input type="range" id="rim-strength" min="0" max="1.5" step="0.01">
            <label>Contact Shadow<span id="contact-shadow-value"></span></label>
            <input type="range" id="contact-shadow" min="0" max="1.0" step="0.01">
        </div>
    </div>
    <div id="water-droplet-container"></div>
    
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- SHADERS (unchanged) ---
        const vertexShader = `
            uniform vec2 u_drag_velocity;
            uniform float u_click_strength;
            uniform float u_stretch;
            uniform float u_squash;
            varying vec3 v_world_position;
            varying vec3 v_normal;
            varying vec4 v_screen_pos;
            varying vec2 v_uv;
            void main() {
                v_uv = uv;
                vec3 displaced_position = position;
                float expansion_factor = 1.0 + u_click_strength * 0.4;
                float squash_factor = 1.0 - u_click_strength * 0.3;
                displaced_position.xy *= expansion_factor;
                displaced_position.z *= squash_factor;
                float drag_strength = length(u_drag_velocity);
                if (drag_strength > 0.001) {
                    vec2 drag_dir = normalize(u_drag_velocity);
                    float projection = dot(displaced_position.xy, drag_dir);
                    displaced_position.xy += drag_dir * projection * drag_strength * u_stretch;
                    vec2 perpendicular_dir = vec2(-drag_dir.y, drag_dir.x);
                    float perp_projection = dot(displaced_position.xy, perpendicular_dir);
                    displaced_position.xy -= perpendicular_dir * perp_projection * drag_strength * u_squash;
                }
                vec4 modelViewPosition = modelViewMatrix * vec4(displaced_position, 1.0);
                gl_Position = projectionMatrix * modelViewPosition;
                v_screen_pos = gl_Position;
                v_world_position = (modelMatrix * vec4(displaced_position, 1.0)).xyz;
                v_normal = normalize(normalMatrix * displaced_position);
            }
        `;

        const fragmentShader = `
            uniform sampler2D u_background_tex;
            uniform samplerCube u_env_map;
            uniform float u_refraction;
            uniform float u_fresnel_power;
            uniform float u_rim_start;
            uniform float u_rim_strength;
            uniform float u_contact_shadow;
            varying vec3 v_world_position;
            varying vec3 v_normal;
            varying vec4 v_screen_pos;
            varying vec2 v_uv;
            const float IOR = 1.333;
            void main() {
                vec3 N = normalize(v_normal);
                vec3 V = normalize(cameraPosition - v_world_position);
                vec3 R_refl = reflect(-V, N);
                vec4 reflected_color = textureCube(u_env_map, R_refl);
                vec3 R_refr = refract(-V, N, 1.0 / IOR);
                vec2 screen_uv = v_screen_pos.xy / v_screen_pos.w;
                vec2 refr_uv = screen_uv + R_refr.xy * u_refraction;
                refr_uv = refr_uv * 0.5 + 0.5;
                vec4 refracted_color = texture2D(u_background_tex, refr_uv);
                refracted_color.rgb *= 1.1;
                float fresnel = 1.0 - dot(V, N);
                fresnel = pow(fresnel, u_fresnel_power);
                fresnel = clamp(0.05 + fresnel, 0.0, 1.0);
                vec4 final_color = mix(refracted_color, reflected_color, fresnel);
                float rim = 1.0 - dot(N, vec3(0.0, 0.0, 1.0));
                final_color.rgb *= smoothstep(u_rim_start, 1.0, 1.0 - rim * u_rim_strength);
                float highlight = smoothstep(0.8, 1.0, dot(N, normalize(vec3(0.5, 0.5, 1.0))));
                final_color.rgb += vec3(1.0) * highlight * 0.2;
                float footprint_y = v_uv.y;
                float footprint_alpha = smoothstep(0.15, 0.0, footprint_y) * u_contact_shadow * 0.5;
                final_color.rgb *= (1.0 - footprint_alpha);
                gl_FragColor = final_color;
            }
        `;

        // --- Simulation Logic ---
        const settings = {
            stretch: 0.4,
            squash: 0.2,
            damping: 0.9,
            refraction: 0.05,
            fresnel: 10,
            rimStart: 0.1,
            rimStrength: 0.1,
            contactShadow: 0.5 
        };

        let scene, camera, renderer, waterDrop, uniforms;
        const mouse = new THREE.Vector2(0, 0);
        const dragVelocity = new THREE.Vector2(0, 0);
        let clickStrength = 0.0;
        let targetClickStrength = 0.0;
        const zoom = 10.0;
        
        // OPTIMIZATION: Removed html2canvas. This function directly creates the grid texture.
        // It's much faster and avoids a heavy dependency.
        function createGridTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, 256, 256);
            
            ctx.strokeStyle = '#cccccc';
            ctx.lineWidth = 1;
            ctx.setLineDash([1, 19]); // Match 20px grid size
            
            ctx.beginPath();
            for(let i = 0.5; i < 256; i += 20) {
                ctx.moveTo(i, 0); ctx.lineTo(i, 256);
                ctx.moveTo(0, i); ctx.lineTo(256, i);
            }
            ctx.stroke();
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping; // Ensure it tiles
            return texture;
        }

        function init() {
            const container = document.getElementById('water-droplet-container');
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setClearColor(0x000000, 0);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            scene = new THREE.Scene();
            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.OrthographicCamera(-zoom * aspect, zoom * aspect, zoom, -zoom, 1, 1000);
            camera.position.z = 10;
            
            const whitePixelBase64 = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/wcAAwAB/epv2AAAAABJRU5CYII=';
            const envMap = new THREE.CubeTextureLoader().load(Array(6).fill(whitePixelBase64));

            uniforms = {
                u_drag_velocity: { value: dragVelocity },
                u_click_strength: { value: 0.0 },
                u_background_tex: { value: createGridTexture() },
                u_env_map: { value: envMap },
                u_stretch: { value: settings.stretch },
                u_squash: { value: settings.squash },
                u_refraction: { value: settings.refraction },
                u_fresnel_power: { value: settings.fresnel },
                u_rim_start: { value: settings.rimStart },
                u_rim_strength: { value: settings.rimStrength },
                u_contact_shadow: { value: settings.contactShadow },
            };

            // OPTIMIZATION: Reduced sphere segments from 128x128 to 64x64.
            // This is a 4x reduction in vertices for a huge performance gain with no noticeable visual impact.
            const geometry = new THREE.SphereGeometry(0.7, 64, 64);
            const material = new THREE.ShaderMaterial({ vertexShader, fragmentShader, uniforms, transparent: true });
            waterDrop = new THREE.Mesh(geometry, material);
            scene.add(waterDrop);

            setupControls();
            
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mousedown', () => { targetClickStrength = 1.0; });
            window.addEventListener('mouseup', () => { targetClickStrength = 0.0; });
            
            onWindowResize(); // Set initial size
            animate();
        }

        function setupControls() {
            Object.keys(settings).forEach(key => {
                const slider = document.getElementById(key);
                if (!slider) return;

                const valueSpan = document.getElementById(`${key}-value`);
                
                slider.value = settings[key];
                valueSpan.textContent = parseFloat(settings[key]).toFixed(3);

                slider.addEventListener('input', () => {
                    const value = parseFloat(slider.value);
                    settings[key] = value;
                    valueSpan.textContent = value.toFixed(3);

                    // OPTIMIZATION: Update uniforms directly on input, not every frame.
                    switch(key) {
                        case 'stretch':       uniforms.u_stretch.value = value; break;
                        case 'squash':        uniforms.u_squash.value = value; break;
                        case 'refraction':    uniforms.u_refraction.value = value; break;
                        case 'fresnel':       uniforms.u_fresnel_power.value = value; break;
                        case 'rimStart':      uniforms.u_rim_start.value = value; break;
                        case 'rimStrength':   uniforms.u_rim_strength.value = value; break;
                        case 'contactShadow': uniforms.u_contact_shadow.value = value; break;
                        // 'damping' is used in JS logic, not a uniform.
                    }
                });
            });
        }
        
        // OPTIMIZATION: Implemented a proper resize handler.
        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -zoom * aspect;
            camera.right = zoom * aspect;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            const aspect = window.innerWidth / window.innerHeight;
            mouse.x = ((event.clientX / window.innerWidth) * 2 - 1) * zoom * aspect;
            mouse.y = (-(event.clientY / window.innerHeight) * 2 + 1) * zoom;
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Smoothed click effect
            clickStrength += (targetClickStrength - clickStrength) * 0.1;

            // Physics calculation
            const dragDelta = new THREE.Vector2().subVectors(mouse, waterDrop.position);
            dragVelocity.lerp(dragDelta, 0.1).multiplyScalar(settings.damping);

            // Position smoothing
            waterDrop.position.x += (mouse.x - waterDrop.position.x) * 0.08;
            waterDrop.position.y += (mouse.y - waterDrop.position.y) * 0.08;
            
            // OPTIMIZATION: Only update uniforms that change every frame.
            uniforms.u_click_strength.value = clickStrength;
            // The u_drag_velocity uniform's value is an object that is mutated, so it's always up to date.
            
            renderer.render(scene, camera);
        }
        
        init();
    </script>
</body>
</html>
