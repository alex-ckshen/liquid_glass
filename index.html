<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Water Droplet - Tuning Console</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: #ffffff; /* White background */
            background-image: 
                linear-gradient(#cccccc 1px, transparent 1px),
                linear-gradient(90deg, #cccccc 1px, transparent 1px);
            background-size: 20px 20px; /* Grid size */
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            cursor: pointer;
        }

        #water-droplet-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        #controls {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 10px;
            color: white;
            z-index: 1000;
            font-size: 12px;
            width: 250px;
        }
        .control-group { margin-bottom: 10px; }
        .control-group h3 { margin: 0 0 10px 0; font-size: 14px; border-bottom: 1px solid rgba(255,255,255,0.2); padding-bottom: 5px; }
        .control-group label { display: block; margin-bottom: 3px; }
        .control-group input[type="range"] { width: 100%; }
        .control-group span { float: right; font-weight: bold; }
    </style>
</head>
<body>
    <div id="controls">
        <div class="control-group">
            <h3>Physics</h3>
            <label>Stretch<span id="stretch-value"></span></label>
            <input type="range" id="stretch" min="0" max="0.5" step="0.01">
            <label>Squash<span id="squash-value"></span></label>
            <input type="range" id="squash" min="0" max="0.5" step="0.01">
            <label>Damping<span id="damping-value"></span></label>
            <input type="range" id="damping" min="0.8" max="0.99" step="0.001">
        </div>
        <div class="control-group">
            <h3>Appearance</h3>
            <label>Refraction<span id="refraction-value"></span></label>
            <input type="range" id="refraction" min="0" max="0.3" step="0.01">
            <label>Fresnel Power<span id="fresnel-value"></span></label>
            <input type="range" id="fresnel" min="1" max="15" step="0.1">
            <label>Rim Start<span id="rim-start-value"></span></label>
            <input type="range" id="rim-start" min="0.1" max="1.0" step="0.01">
            <label>Rim Strength<span id="rim-strength-value"></span></label>
            <input type="range" id="rim-strength" min="0" max="1.5" step="0.01">
            <label>Contact Shadow<span id="contact-shadow-value"></span></label>
            <input type="range" id="contact-shadow" min="0" max="1.0" step="0.01">
        </div>
    </div>
    <div id="water-droplet-container"></div>
    
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        const vertexShader = `
            uniform vec2 u_drag_velocity;
            uniform float u_click_strength;
            uniform float u_stretch;
            uniform float u_squash;

            varying vec3 v_world_position;
            varying vec3 v_normal;
            varying vec4 v_screen_pos;
            varying vec2 v_uv;

            void main() {
                v_uv = uv;
                vec3 displaced_position = position;

                float expansion_factor = 1.0 + u_click_strength * 0.4;
                float squash_factor = 1.0 - u_click_strength * 0.3;
                displaced_position.xy *= expansion_factor;
                displaced_position.z *= squash_factor;

                float drag_strength = length(u_drag_velocity);
                if (drag_strength > 0.001) {
                    vec2 drag_dir = normalize(u_drag_velocity);
                    float projection = dot(displaced_position.xy, drag_dir);
                    displaced_position.xy += drag_dir * projection * drag_strength * u_stretch;
                    vec2 perpendicular_dir = vec2(-drag_dir.y, drag_dir.x);
                    float perp_projection = dot(displaced_position.xy, perpendicular_dir);
                    displaced_position.xy -= perpendicular_dir * perp_projection * drag_strength * u_squash;
                }

                vec4 modelViewPosition = modelViewMatrix * vec4(displaced_position, 1.0);
                gl_Position = projectionMatrix * modelViewPosition;
                v_screen_pos = gl_Position;
                v_world_position = (modelMatrix * vec4(displaced_position, 1.0)).xyz;
                v_normal = normalize(normalMatrix * displaced_position);
            }
        `;

        const fragmentShader = `
            uniform sampler2D u_background_tex;
            uniform samplerCube u_env_map;
            uniform float u_refraction;
            uniform float u_fresnel_power;
            uniform float u_rim_start;
            uniform float u_rim_strength;
            uniform float u_contact_shadow;
            
            varying vec3 v_world_position;
            varying vec3 v_normal;
            varying vec4 v_screen_pos;
            varying vec2 v_uv;

            const float IOR = 1.333; // Index of Refraction for water

            void main() {
                vec3 N = normalize(v_normal);
                vec3 V = normalize(cameraPosition - v_world_position);

                vec3 R_refl = reflect(-V, N);
                vec4 reflected_color = textureCube(u_env_map, R_refl);

                vec2 screen_uv = v_screen_pos.xy / v_screen_pos.w;

                // --- Advanced Refraction: Blend flat and curved magnification ---
                // This combines both previous methods to get the best of both worlds:
                // a flat magnification in the center that curves towards the edges.

                // 1. Calculate the physically-based curved refraction vector
                vec3 R_refr_curved = refract(-V, N, 1.0 / IOR);

                // 2. Define the two different refraction styles we want to blend
                // Style A: "Flat" magnification, good for the center of the lens
                vec2 uv_flat = screen_uv - N.xy * u_refraction;
                // Style B: "Curved" magnification, good for the edges to show depth
                vec2 uv_curved = screen_uv - R_refr_curved.xy * u_refraction;

                // 3. Create a mix factor based on the viewing angle (stronger at the edges)
                // This is 0 at the center and 1 at the edges.
                float edge_factor = 1.0 - dot(V, N); 
                // We use pow() to make the curve effect "kick in" more towards the edges.
                edge_factor = pow(edge_factor, 3.0);

                // 4. Mix between the flat and curved styles based on the edge_factor
                vec2 refr_uv = mix(uv_flat, uv_curved, edge_factor);

                refr_uv = refr_uv * 0.5 + 0.5;
                vec4 refracted_color = texture2D(u_background_tex, refr_uv);
                
                refracted_color.rgb *= 1.1;

                float fresnel = 1.0 - dot(V, N);
                fresnel = pow(fresnel, u_fresnel_power);
                fresnel = clamp(0.05 + fresnel, 0.0, 1.0);

                vec4 final_color = mix(refracted_color, reflected_color, fresnel);

                float rim = 1.0 - dot(N, vec3(0.0, 0.0, 1.0));
                final_color.rgb *= smoothstep(u_rim_start, 1.0, 1.0 - rim * u_rim_strength);

                float highlight = smoothstep(0.8, 1.0, dot(N, normalize(vec3(0.5, 0.5, 1.0))));
                final_color.rgb += vec3(1.0) * highlight * 0.2;

                float footprint_y = v_uv.y;
                float footprint_alpha = smoothstep(0.15, 0.0, footprint_y) * u_contact_shadow * 0.5;
                final_color.rgb *= (1.0 - footprint_alpha);

                gl_FragColor = final_color;
            }
        `;

        const whitePixelBase64 = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/wcAAwAB/epv2AAAAABJRU5CYII=';
        const envMapBase64 = [whitePixelBase64, whitePixelBase64, whitePixelBase64, whitePixelBase64, whitePixelBase64, whitePixelBase64];

        const settings = {
            stretch: 0.4,
            squash: 0.2,
            damping: 0.9,
            refraction: 0.1, 
            fresnel: 10,
            rimStart: 0.1,
            rimStrength: 0.1,
            contactShadow: 0.5 
        };

        let scene, camera, renderer, uniforms;
        let waterDrop, mouse = new THREE.Vector2(0, 0), dragVelocity = new THREE.Vector2(0, 0);
        let clickStrength = 0.0, targetClickStrength = 0.0;
        const zoom = 5.0;

        async function init() {
            const domCanvas = await html2canvas(document.body, {
                useCORS: true,
                logging: false,
                scale: window.devicePixelRatio,
                backgroundColor: null, 
                ignoreElements: (element) => 
                    element.id === 'controls' || element.id === 'water-droplet-container'
            });

            const backgroundTexture = new THREE.CanvasTexture(domCanvas);
            const container = document.getElementById('water-droplet-container');
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setClearColor(0x000000, 0);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            const aspect = window.innerWidth / window.innerHeight;
            scene = new THREE.Scene();
            camera = new THREE.OrthographicCamera(-zoom * aspect, zoom * aspect, zoom, -zoom, 1, 1000);
            camera.position.z = 10;
            
            const envMap = new THREE.CubeTextureLoader().load(envMapBase64);

            uniforms = {
                u_drag_velocity: { value: dragVelocity },
                u_click_strength: { value: clickStrength },
                u_background_tex: { value: backgroundTexture },
                u_env_map: { value: envMap },
                u_stretch: { value: settings.stretch },
                u_squash: { value: settings.squash },
                u_refraction: { value: settings.refraction },
                u_fresnel_power: { value: settings.fresnel },
                u_rim_start: { value: settings.rimStart },
                u_rim_strength: { value: settings.rimStrength },
                u_contact_shadow: { value: settings.contactShadow },
            };
            
            const geometry = new THREE.SphereGeometry(3, 128, 128);
            waterDrop = new THREE.Mesh(geometry, new THREE.ShaderMaterial({ vertexShader, fragmentShader, uniforms, transparent: true }));
            scene.add(waterDrop);

            setupControls();
            
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mousedown', () => { targetClickStrength = 1.0; });
            window.addEventListener('mouseup', () => { targetClickStrength = 0.0; });

            animate();
        }

        function setupControls() {
            const sliders = {
                stretch: document.getElementById('stretch'),
                squash: document.getElementById('squash'),
                damping: document.getElementById('damping'),
                refraction: document.getElementById('refraction'),
                fresnel: document.getElementById('fresnel'),
                rimStart: document.getElementById('rim-start'),
                rimStrength: document.getElementById('rim-strength'),
                contactShadow: document.getElementById('contact-shadow'),
            };
            const values = {
                stretch: document.getElementById('stretch-value'),
                squash: document.getElementById('squash-value'),
                damping: document.getElementById('damping-value'),
                refraction: document.getElementById('refraction-value'),
                fresnel: document.getElementById('fresnel-value'),
                rimStart: document.getElementById('rim-start-value'),
                rimStrength: document.getElementById('rim-strength-value'),
                contactShadow: document.getElementById('contact-shadow-value'),
            };

            for (const key in sliders) {
                sliders[key].value = settings[key];
                values[key].textContent = parseFloat(settings[key]).toFixed(3);

                sliders[key].addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    settings[key] = value;
                    values[key].textContent = value.toFixed(3);
                });
            }
        }
        
        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -zoom * aspect;
            camera.right = zoom * aspect;
            camera.top = zoom;
            camera.bottom = -zoom;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            const aspect = window.innerWidth / window.innerHeight;
            mouse.x = ((event.clientX / window.innerWidth) * 2 - 1) * zoom * aspect;
            mouse.y = (-(event.clientY / window.innerHeight) * 2 + 1) * zoom;
        }

        function animate() {
            requestAnimationFrame(animate);
            clickStrength += (targetClickStrength - clickStrength) * 0.1;

            const dragDelta = new THREE.Vector2().subVectors(mouse, waterDrop.position);
            dragVelocity.lerp(dragDelta, 0.1);
            dragVelocity.multiplyScalar(settings.damping);

            waterDrop.position.x += (mouse.x - waterDrop.position.x) * 0.08;
            waterDrop.position.y += (mouse.y - waterDrop.position.y) * 0.08;
            
            uniforms.u_click_strength.value = clickStrength;
            uniforms.u_stretch.value = settings.stretch;
            uniforms.u_squash.value = settings.squash;
            uniforms.u_refraction.value = settings.refraction;
            uniforms.u_fresnel_power.value = settings.fresnel;
            uniforms.u_rim_start.value = settings.rimStart;
            uniforms.u_rim_strength.value = settings.rimStrength;
            uniforms.u_contact_shadow.value = settings.contactShadow;
            
            renderer.render(scene, camera);
        }
        
        init();
    </script>
</body>
</html>
